<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”¨æˆ·ä¿¡æ¯æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            margin-top: 20px;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .status.success { background-color: #d4edda; color: #155724; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .status.info { background-color: #d1ecf1; color: #0c5460; }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .user-info {
            background-color: #e7f3ff;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 15px 0;
        }
        .user-info h4 {
            margin: 0 0 10px 0;
            color: #007bff;
        }
        .user-info p {
            margin: 5px 0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ‘¤ ç”¨æˆ·ä¿¡æ¯æµ‹è¯•</h1>
        
        <div class="test-section">
            <h3>ğŸ“‹ æµ‹è¯•ç›®æ ‡</h3>
            <p><strong>é—®é¢˜</strong>: åå°æ—¥å¿—æ˜¾ç¤ºç”¨æˆ·åå’ŒIDéƒ½æ˜¯"undefined"</p>
            <p><strong>ä¿®å¤</strong>: æ›´æ–°JWT tokenåŒ…å«å®Œæ•´ç”¨æˆ·ä¿¡æ¯ï¼Œä¿®å¤WebSocketè¿æ¥æ—¥å¿—</p>
        </div>
        
        <div id="status" class="status info">
            å‡†å¤‡æµ‹è¯•ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤º...
        </div>
        
        <div class="test-section">
            <h3>ğŸ”§ æµ‹è¯•æ“ä½œ</h3>
            <button onclick="loginTestUser()">ç™»å½•æµ‹è¯•ç”¨æˆ·</button>
            <button onclick="checkLoginStatus()">æ£€æŸ¥ç™»å½•çŠ¶æ€</button>
            <button onclick="getUserInfo()">è·å–ç”¨æˆ·ä¿¡æ¯</button>
            <button onclick="testWebSocketConnection()">æµ‹è¯•WebSocketè¿æ¥</button>
            <button onclick="checkJWTToken()">æ£€æŸ¥JWT Token</button>
            <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
        </div>
        
        <div id="userInfoDisplay" class="user-info" style="display: none;">
            <h4>å½“å‰ç”¨æˆ·ä¿¡æ¯</h4>
            <p><strong>ç”¨æˆ·ID:</strong> <span id="userId">-</span></p>
            <p><strong>ç”¨æˆ·å:</strong> <span id="userName">-</span></p>
            <p><strong>é‚®ç®±:</strong> <span id="userEmail">-</span></p>
            <p><strong>TokençŠ¶æ€:</strong> <span id="tokenStatus">-</span></p>
        </div>
        
        <div class="test-section">
            <h3>ğŸ“ æµ‹è¯•æ—¥å¿—</h3>
            <div id="logContainer" class="log"></div>
        </div>
    </div>

    <script>
        let logContainer;
        let statusDiv;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            logContainer = document.getElementById('logContainer');
            statusDiv = document.getElementById('status');
            log('ğŸ“„ ç”¨æˆ·ä¿¡æ¯æµ‹è¯•å·¥å…·å·²åŠ è½½');
            
            // è‡ªåŠ¨æ£€æŸ¥ç™»å½•çŠ¶æ€
            setTimeout(checkLoginStatus, 1000);
        });

        // æ—¥å¿—å‡½æ•°
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}\n`;
            
            if (logContainer) {
                logContainer.textContent += logMessage;
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            
            console.log(message);
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(message, type = 'info') {
            if (statusDiv) {
                statusDiv.textContent = message;
                statusDiv.className = `status ${type}`;
            }
        }

        // æ›´æ–°ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤º
        function updateUserInfo(userInfo) {
            document.getElementById('userId').textContent = userInfo.id || 'undefined';
            document.getElementById('userName').textContent = userInfo.name || 'undefined';
            document.getElementById('userEmail').textContent = userInfo.email || 'undefined';
            document.getElementById('tokenStatus').textContent = userInfo.tokenValid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ';
            document.getElementById('userInfoDisplay').style.display = 'block';
        }

        // æ£€æŸ¥ç™»å½•çŠ¶æ€
        async function checkLoginStatus() {
            try {
                log('ğŸ” æ£€æŸ¥ç™»å½•çŠ¶æ€...');
                
                if (typeof chrome === 'undefined' || !chrome.runtime) {
                    log('âŒ æœªæ£€æµ‹åˆ°Chromeæ‰©å±•ç¯å¢ƒ');
                    updateStatus('è¯·åœ¨Chromeæ‰©å±•ä¸­æ‰“å¼€æ­¤é¡µé¢', 'error');
                    return;
                }
                
                const response = await chrome.runtime.sendMessage({
                    type: 'CHECK_LOGIN_STATUS'
                });
                
                if (response.loggedIn) {
                    log('âœ… ç”¨æˆ·å·²ç™»å½•');
                    log('ğŸ‘¤ ç”¨æˆ·ä¿¡æ¯: ' + JSON.stringify(response.user));
                    updateStatus('ç”¨æˆ·å·²ç™»å½•', 'success');
                    
                    updateUserInfo({
                        id: response.user.id,
                        name: response.user.name,
                        email: response.user.email,
                        tokenValid: true
                    });
                } else {
                    log('âŒ ç”¨æˆ·æœªç™»å½•');
                    if (response.error) {
                        log('é”™è¯¯ä¿¡æ¯: ' + response.error);
                    }
                    updateStatus('ç”¨æˆ·æœªç™»å½•', 'error');
                }
                
            } catch (error) {
                log('âŒ æ£€æŸ¥ç™»å½•çŠ¶æ€å¤±è´¥: ' + error.message);
                updateStatus('æ£€æŸ¥ç™»å½•çŠ¶æ€å¤±è´¥', 'error');
            }
        }

        // è·å–ç”¨æˆ·ä¿¡æ¯
        async function getUserInfo() {
            try {
                log('ğŸ“¡ è·å–ç”¨æˆ·ä¿¡æ¯...');
                
                const settings = await chrome.storage.sync.get(['token', 'serverUrl']);
                if (!settings.token) {
                    log('âŒ æœªæ‰¾åˆ°tokenï¼Œå°è¯•ç™»å½•æµ‹è¯•ç”¨æˆ·...');
                    await loginTestUser();
                    return;
                }
                
                const serverUrl = settings.serverUrl || 'http://localhost:3001';
                
                const response = await fetch(`${serverUrl}/auth/me`, {
                    headers: {
                        'Authorization': `Bearer ${settings.token}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    log('âœ… è·å–ç”¨æˆ·ä¿¡æ¯æˆåŠŸ');
                    log('ğŸ‘¤ æœåŠ¡å™¨è¿”å›: ' + JSON.stringify(data.user));
                    
                    updateUserInfo({
                        id: data.user.id,
                        name: data.user.name,
                        email: data.user.email,
                        tokenValid: true
                    });
                    
                    updateStatus('ç”¨æˆ·ä¿¡æ¯è·å–æˆåŠŸ', 'success');
                } else {
                    log('âŒ è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥: ' + response.status);
                    if (response.status === 401) {
                        log('ğŸ”„ Tokenå¯èƒ½å·²è¿‡æœŸï¼Œå°è¯•é‡æ–°ç™»å½•...');
                        await loginTestUser();
                    } else {
                        updateStatus('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥', 'error');
                    }
                }
                
            } catch (error) {
                log('âŒ è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥: ' + error.message);
                updateStatus('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥', 'error');
            }
        }

        // ç™»å½•æµ‹è¯•ç”¨æˆ·
        async function loginTestUser() {
            try {
                log('ğŸ” å°è¯•ç™»å½•æµ‹è¯•ç”¨æˆ·...');
                
                const serverUrl = 'http://localhost:3001';
                
                const response = await fetch(`${serverUrl}/auth/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: 'leon@example.com',
                        password: 'password123'
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    log('âœ… ç™»å½•æˆåŠŸ');
                    log('ğŸ‘¤ ç”¨æˆ·ä¿¡æ¯: ' + JSON.stringify(data.user));
                    
                    // ä¿å­˜token
                    await chrome.storage.sync.set({
                        token: data.token,
                        serverUrl: serverUrl
                    });
                    
                    updateUserInfo({
                        id: data.user.id,
                        name: data.user.name,
                        email: data.user.email,
                        tokenValid: true
                    });
                    
                    updateStatus('ç™»å½•æˆåŠŸ', 'success');
                } else {
                    const errorData = await response.json();
                    log('âŒ ç™»å½•å¤±è´¥: ' + errorData.error);
                    updateStatus('ç™»å½•å¤±è´¥: ' + errorData.error, 'error');
                }
                
            } catch (error) {
                log('âŒ ç™»å½•å¤±è´¥: ' + error.message);
                updateStatus('ç™»å½•å¤±è´¥', 'error');
            }
        }

        // æµ‹è¯•WebSocketè¿æ¥
        async function testWebSocketConnection() {
            try {
                log('ğŸ”Œ æµ‹è¯•WebSocketè¿æ¥...');
                
                const settings = await chrome.storage.sync.get(['token', 'serverUrl']);
                if (!settings.token) {
                    log('âŒ æœªæ‰¾åˆ°token');
                    updateStatus('è¯·å…ˆç™»å½•', 'error');
                    return;
                }
                
                const serverUrl = settings.serverUrl || 'http://localhost:3001';
                const wsUrl = serverUrl.replace('http', 'ws') + `/ws?token=${settings.token}`;
                
                log('ğŸ”— è¿æ¥åœ°å€: ' + wsUrl);
                
                const ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    log('âœ… WebSocketè¿æ¥æˆåŠŸ');
                    updateStatus('WebSocketè¿æ¥æˆåŠŸï¼Œæ£€æŸ¥åå°æ—¥å¿—', 'success');
                    
                    // å‘é€æµ‹è¯•æ¶ˆæ¯
                    ws.send(JSON.stringify({
                        type: 'ping',
                        message: 'ç”¨æˆ·ä¿¡æ¯æµ‹è¯•'
                    }));
                };
                
                ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    log(`ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯: ${message.type}`);
                    if (message.type === 'connection') {
                        log('ğŸ”— è¿æ¥çŠ¶æ€: ' + message.status);
                    }
                };
                
                ws.onclose = (event) => {
                    log(`ğŸ”Œ WebSocketè¿æ¥å…³é—­: ${event.code}`);
                };
                
                ws.onerror = (error) => {
                    log('âŒ WebSocketé”™è¯¯: ' + error);
                    updateStatus('WebSocketè¿æ¥å¤±è´¥', 'error');
                };
                
                // 10ç§’åå…³é—­è¿æ¥
                setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                        log('ğŸ”Œ ä¸»åŠ¨å…³é—­WebSocketè¿æ¥');
                    }
                }, 10000);
                
            } catch (error) {
                log('âŒ WebSocketè¿æ¥æµ‹è¯•å¤±è´¥: ' + error.message);
                updateStatus('WebSocketè¿æ¥æµ‹è¯•å¤±è´¥', 'error');
            }
        }

        // æ£€æŸ¥JWT Token
        async function checkJWTToken() {
            try {
                log('ğŸ” æ£€æŸ¥JWT Token...');
                
                const settings = await chrome.storage.sync.get(['token']);
                if (!settings.token) {
                    log('âŒ æœªæ‰¾åˆ°token');
                    return;
                }
                
                // è§£æJWT token (ä¸éªŒè¯ç­¾åï¼Œä»…æŸ¥çœ‹å†…å®¹)
                const parts = settings.token.split('.');
                if (parts.length !== 3) {
                    log('âŒ Tokenæ ¼å¼æ— æ•ˆ');
                    return;
                }
                
                try {
                    const payload = JSON.parse(atob(parts[1]));
                    log('ğŸ” Tokenå†…å®¹:');
                    log('  ID: ' + (payload.id || 'undefined'));
                    log('  User ID: ' + (payload.userId || 'undefined'));
                    log('  Name: ' + (payload.name || 'undefined'));
                    log('  Email: ' + (payload.email || 'undefined'));
                    log('  è¿‡æœŸæ—¶é—´: ' + new Date(payload.exp * 1000).toLocaleString());
                    
                    const now = Math.floor(Date.now() / 1000);
                    const isExpired = payload.exp < now;
                    log('  æ˜¯å¦è¿‡æœŸ: ' + (isExpired ? 'æ˜¯' : 'å¦'));
                    
                    if (payload.name && payload.email) {
                        log('âœ… TokenåŒ…å«å®Œæ•´ç”¨æˆ·ä¿¡æ¯');
                        updateStatus('TokenåŒ…å«å®Œæ•´ç”¨æˆ·ä¿¡æ¯', 'success');
                    } else {
                        log('âš ï¸ Tokenç¼ºå°‘ç”¨æˆ·ä¿¡æ¯ï¼Œå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬');
                        updateStatus('Tokenç¼ºå°‘ç”¨æˆ·ä¿¡æ¯ï¼Œéœ€è¦é‡æ–°ç™»å½•', 'error');
                    }
                    
                } catch (decodeError) {
                    log('âŒ è§£æTokenå¤±è´¥: ' + decodeError.message);
                }
                
            } catch (error) {
                log('âŒ æ£€æŸ¥JWT Tokenå¤±è´¥: ' + error.message);
            }
        }

        // æ¸…ç©ºæ—¥å¿—
        function clearLog() {
            if (logContainer) {
                logContainer.textContent = '';
            }
            log('ğŸ“„ æ—¥å¿—å·²æ¸…ç©º');
        }
    </script>
</body>
</html>